/**
 * Service de scan de vulnérabilités pour AutoStack Manager
 * Détecte les vulnérabilités dans les composants des services
 */
const { initializeService } = require('../common/utils/serviceInitializer');
const { asyncHandler } = require('../common/middleware/errorHandler');
const { verifyToken, checkRole } = require('../common/middleware/auth');

// Configuration du service
const SERVICE_NAME = 'vuln-scanner-service';
const PORT = process.env.VULN_SCANNER_PORT || 3004;

/**
 * Initialiser le service de scan de vulnérabilités
 */
const initVulnScanner = async () => {
  // Initialiser le service avec les configurations communes
  const { app, daos, setupErrorHandlers, startServer } = await initializeService(SERVICE_NAME, {
    port: PORT
  });

  // Extraire les DAOs nécessaires
  const { serviceDAO, componentDAO, vulnerabilityDAO, notificationDAO } = daos;

  // Middleware d'authentification pour toutes les routes
  app.use('/api', verifyToken);

  /**
   * Route pour scanner les vulnérabilités d'un service
   * @route POST /api/scan
   */
  app.post('/api/scan', checkRole('admin', 'developer'), asyncHandler(async (req, res) => {
    const { serviceId } = req.body;

    if (!serviceId) {
      return res.status(400).json({
        success: false,
        message: 'ID du service requis'
      });
    }

    // Vérifier si le service existe
    const service = await serviceDAO.findById(serviceId, 'components');
    if (!service) {
      return res.status(404).json({
        success: false,
        message: 'Service non trouvé'
      });
    }

    // Récupérer les composants du service
    const components = await Promise.all(
      service.components.map(compId => componentDAO.findById(compId))
    );

    // Résultats du scan
    const scanResults = {
      serviceId,
      vulnerabilities: [],
      totalVulnerabilities: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0
    };

    // Scanner chaque composant pour les vulnérabilités
    for (const component of components) {
      // Simuler la détection de vulnérabilités (dans une implémentation réelle, cela interrogerait des bases de vulnérabilités)
      const detectedVulns = simulateVulnerabilityDetection(component.name, component.version);
      
      for (const vulnData of detectedVulns) {
        // Créer ou récupérer la vulnérabilité
        let vulnerability = await vulnerabilityDAO.findOne({
          cveId: vulnData.cveId
        });

        if (!vulnerability) {
          vulnerability = await vulnerabilityDAO.create(vulnData);
        }

        // Ajouter la vulnérabilité au service
        await serviceDAO.addVulnerability(serviceId, {
          component: component._id,
          details: vulnerability._id
        });

        // Mettre à jour les compteurs
        scanResults.totalVulnerabilities++;
        scanResults.vulnerabilities.push({
          component: component.name,
          vulnerability: vulnerability
        });

        if (vulnerability.severity === 'critical') scanResults.criticalCount++;
        if (vulnerability.severity === 'high') scanResults.highCount++;
        if (vulnerability.severity === 'medium') scanResults.mediumCount++;
        if (vulnerability.severity === 'low') scanResults.lowCount++;

        // Créer une notification pour les vulnérabilités critiques et élevées
        if (['critical', 'high'].includes(vulnerability.severity)) {
          await notificationDAO.create({
            title: `Vulnérabilité ${vulnerability.severity} détectée`,
            message: `${vulnerability.title} détectée dans ${component.name} v${component.version}`,
            type: 'vulnerability',
            severity: vulnerability.severity,
            service: serviceId,
            // Notifier tous les développeurs et administrateurs
            recipients: [] // Dans une implémentation réelle, on récupérerait les utilisateurs avec ces rôles
          });
        }
      }
    }

    // Mettre à jour le statut du service
    let newStatus = 'secure';
    if (scanResults.criticalCount > 0 || scanResults.highCount > 0) {
      newStatus = 'vulnerable';
    }

    await serviceDAO.update(serviceId, { status: newStatus });

    res.status(200).json({
      success: true,
      message: 'Scan de vulnérabilités terminé',
      results: scanResults
    });
  }));

  /**
   * Route pour obtenir les vulnérabilités d'un service
   * @route GET /api/service/:serviceId/vulnerabilities
   */
  app.get('/api/service/:serviceId/vulnerabilities', asyncHandler(async (req, res) => {
    const { serviceId } = req.params;

    // Vérifier si le service existe
    const service = await serviceDAO.findById(serviceId, ['components', 'vulnerabilities.component', 'vulnerabilities.details']);
    if (!service) {
      return res.status(404).json({
        success: false,
        message: 'Service non trouvé'
      });
    }

    res.status(200).json({
      success: true,
      vulnerabilities: service.vulnerabilities
    });
  }));

  /**
   * Route pour obtenir toutes les vulnérabilités
   * @route GET /api/vulnerabilities
   */
  app.get('/api/vulnerabilities', asyncHandler(async (req, res) => {
    const vulnerabilities = await vulnerabilityDAO.findAll();

    res.status(200).json({
      success: true,
      count: vulnerabilities.length,
      vulnerabilities
    });
  }));

  /**
   * Route pour obtenir les vulnérabilités par sévérité
   * @route GET /api/vulnerabilities/severity/:severity
   */
  app.get('/api/vulnerabilities/severity/:severity', asyncHandler(async (req, res) => {
    const { severity } = req.params;
    const vulnerabilities = await vulnerabilityDAO.findBySeverity(severity);

    res.status(200).json({
      success: true,
      count: vulnerabilities.length,
      vulnerabilities
    });
  }));

  // Configurer les gestionnaires d'erreurs
  setupErrorHandlers();

  // Démarrer le serveur
  const server = await startServer();

  return { app, server };
};

/**
 * Simuler la détection de vulnérabilités
 * @param {string} componentName - Nom du composant
 * @param {string} version - Version du composant
 * @returns {Array} - Liste de vulnérabilités détectées
 */
function simulateVulnerabilityDetection(componentName, version) {
  // Dans une implémentation réelle, cela interrogerait des bases de vulnérabilités
  const vulnerabilities = [];
  
  // Simuler quelques vulnérabilités pour certains composants
  if (componentName === 'Express' && version.startsWith('4.')) {
    vulnerabilities.push({
      cveId: 'CVE-2022-1234',
      title: 'Vulnérabilité XSS dans Express',
      description: 'Une vulnérabilité de type Cross-Site Scripting (XSS) a été découverte dans Express.js',
      severity: 'high',
      affectedVersions: ['4.16.0', '4.16.1', '4.16.2', '4.16.3', '4.16.4', '4.17.0', '4.17.1'],
      fixedInVersion: '4.17.2',
      references: ['https://example.com/cve-2022-1234'],
      discoveredAt: new Date()
    });
  }
  
  if (componentName === 'Node.js' && version.startsWith('16.')) {
    vulnerabilities.push({
      cveId: 'CVE-2022-5678',
      title: 'Déni de service dans Node.js',
      description: 'Une vulnérabilité de déni de service a été découverte dans le module HTTP de Node.js',
      severity: 'medium',
      affectedVersions: ['16.0.0', '16.1.0', '16.2.0', '16.3.0', '16.4.0', '16.5.0'],
      fixedInVersion: '16.6.0',
      references: ['https://example.com/cve-2022-5678'],
      discoveredAt: new Date()
    });
  }
  
  if (componentName === 'MongoDB' && version.startsWith('5.0')) {
    vulnerabilities.push({
      cveId: 'CVE-2022-9012',
      title: 'Injection NoSQL dans MongoDB',
      description: 'Une vulnérabilité d\'injection NoSQL a été découverte dans MongoDB',
      severity: 'critical',
      affectedVersions: ['5.0.0', '5.0.1', '5.0.2', '5.0.3', '5.0.4', '5.0.5'],
      fixedInVersion: '5.0.6',
      references: ['https://example.com/cve-2022-9012'],
      discoveredAt: new Date()
    });
  }
  
  return vulnerabilities;
}

// Démarrer le service si ce fichier est exécuté directement
if (require.main === module) {
  initVulnScanner().catch(err => {
    console.error('Erreur lors de l\'initialisation du service de scan de vulnérabilités:', err);
    process.exit(1);
  });
}

module.exports = { initVulnScanner };
